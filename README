//Package UnThermo
//after unfinnigan http://code.google.com/p/unfinnigan/wiki/FileLayoutOverview

//example use case:
package main

import (
	"bitbucket.org/proteinspector/unthermo"
	"flag"
	"fmt"
	"log"
//	"sort"
)

func main() {
	n := flag.Uint64("scan", 0, "the scan number")
	flag.Parse()

	for _, filename := range flag.Args() {
		hdr := new(unthermo.FileHeader)
		info := new(unthermo.Info)
		rh := new(unthermo.RunHeader)

		//save position in file after reading, we need to sequentially
		//read some things in order to get to actuall byte addresses
		pos := unthermo.ReadFile(filename, 0, 0, hdr)
		ver := hdr.Version

		pos = unthermo.ReadFile(filename, pos, ver, new(unthermo.SequencerRow))
		pos = unthermo.ReadFile(filename, pos, 0, new(unthermo.AutoSamplerInfo))
		unthermo.ReadFile(filename, pos, ver, info)

		//in info we finally have an address, let's read the RunHeader,
		//it contains besides general info two interesting addresses:
		//ScanindexAddr (with the scan headers) and ScantrailerAddr (which
		//includes orbitrap Hz-m/z conversion parameters and info about the scans)
		unthermo.ReadFile(filename, info.Preamble.RunHeaderAddr, ver, rh)

		//first we read the n'th ScanIndexEntry, but why not read all
		//unthermo.ReadFile(filename, rh.ScanindexAddr+(*n-1)*entry.Size(ver), ver, entry)
		nScans := uint64(rh.SampleInfo.LastScanNumber - rh.SampleInfo.FirstScanNumber + 1)
		scanindexentries := make([]unthermo.ScanIndexEntry, nScans)
		for i := range scanindexentries {
			unthermo.ReadFile(filename, rh.ScanindexAddr+uint64(i)*scanindexentries[i].Size(ver), ver, &scanindexentries[i])
		}

		//For later conversion of frequency values to m/z, we need a ScanEvent
		//The list of them starts an uint32 later than ScantrailerAddr
		//the uint32 contains the number of ScanEvents, but we know this
		//already through SampleInfo
		pos = rh.ScantrailerAddr + 4

		//the ScanEvents are of variable size and have no pointer to
		//them, we need to read at least all the ones preceding n
		//but as on modern systems we have enough memory, we read them all
		scanevents := make([]unthermo.ScanEvent, nScans)
		for i := range scanevents {
			pos = unthermo.ReadFile(filename, pos, ver, &scanevents[i])
		}

		if *n > 0 {
			if *n < uint64(rh.SampleInfo.FirstScanNumber) || *n > uint64(rh.SampleInfo.LastScanNumber) {
				log.Fatal("scan number out of range: ", rh.SampleInfo.FirstScanNumber, ", ", rh.SampleInfo.LastScanNumber)
			}
			scanindexentries = scanindexentries[*n-1 : *n]
			scanevents = scanevents[*n-1 : *n]
		}

		m := make(map[float64]float32)
		for s := range scanindexentries {
			//read Scan Packet for the above scan number
			scan := new(unthermo.ScanDataPacket)
			unthermo.ReadFile(filename, rh.DataAddr+scanindexentries[s].Offset, 0, scan)

			//convert the Hz values into m/z and list the signals
			for i := uint32(0); i < scan.Profile.PeakCount; i++ {
				for j := uint32(0); j < scan.Profile.Chunks[i].Nbins; j++ {
					m[scanevents[s].Convert(scan.Profile.FirstValue+float64(scan.Profile.Chunks[i].Firstbin+j)*scan.Profile.Step)+float64(scan.Profile.Chunks[i].Fudge)] += scan.Profile.Chunks[i].Signal[j]
					fmt.Println(scanevents[s].Convert(scan.Profile.FirstValue+float64(scan.Profile.Chunks[i].Firstbin+j)*scan.Profile.Step)+float64(scan.Profile.Chunks[i].Fudge), scan.Profile.Chunks[i].Signal[j])
				}
			}
		}
//		fmt.Println(len(m))
//		var keys []float64
//		for k := range m {
//			keys = append(keys, k)
//		}
//		sort.Float64s(keys)
//		fmt.Println(keys[0], keys[len(keys)-1])
	}
}
