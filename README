//Package UnThermo
//after unfinnigan http://code.google.com/p/unfinnigan/wiki/FileLayoutOverview

//example use case:
package main

import (
	"bitbucket.org/proteinspector/unthermo"
	"flag"
	"fmt"
	"log"
	"sort"
)

func main() {
	var sn uint64
	flag.Uint64Var(&sn, "scan", 0, "the scan number")
	flag.Parse()

	for _, filename := range flag.Args() {
		PrintOther(filename, 1)
	}
}

func PrintScan(filename string, sn uint64) {

	hdr := new(unthermo.FileHeader)
	info := new(unthermo.RawFileInfo)
	rh := new(unthermo.RunHeader)
	sie := new(unthermo.ScanIndexEntry)

	//save position in file after reading, we need to sequentially
	//read some things in order to get to actuall byte addresses
	pos := unthermo.ReadFile(filename, 0, 0, hdr)
	ver := hdr.Version

	pos = unthermo.ReadFile(filename, pos, ver, new(unthermo.SequencerRow))
	pos = unthermo.ReadFile(filename, pos, 0, new(unthermo.AutoSamplerInfo))
	unthermo.ReadFile(filename, pos, ver, info)

	//in info we finally have an address, let's read the MS RunHeader,
	//it contains besides general info two interesting addresses:
	//ScanindexAddr (with the scan headers) and ScantrailerAddr (which
	//includes orbitrap Hz-m/z conversion parameters and info about the scans)
	unthermo.ReadFile(filename, info.Preamble.RunHeaderAddr[0], ver, rh)

	if sn < uint64(rh.SampleInfo.FirstScanNumber) || sn > uint64(rh.SampleInfo.LastScanNumber) {
		log.Fatal("scan number out of range: ", rh.SampleInfo.FirstScanNumber, ", ", rh.SampleInfo.LastScanNumber)
	}

	//we can read the n'th ScanIndexEntry
	unthermo.ReadFile(filename, rh.ScanindexAddr+(sn-1)*sie.Size(ver), ver, sie)

	//For later conversion of frequency values to m/z, we need a ScanEvent
	//The list of them starts an uint32 later than ScantrailerAddr
	//the uint32 contains the number of ScanEvents, but we know this
	//already through SampleInfo
	pos = rh.ScantrailerAddr + 4

	//the ScanEvents are of variable size and have no pointer to
	//them, we need to read at least all the ones preceding n
	//but as on modern systems we have enough memory, we read them all
	scanevent := new(unthermo.ScanEvent)
	for i := uint64(0); i < sn; i++ {
		pos = unthermo.ReadFile(filename, pos, ver, scanevent)
	}

	//read Scan Packet for the above scan number
	scan := new(unthermo.ScanDataPacket)
	unthermo.ReadFile(filename, rh.DataAddr+sie.Offset, 0, scan)

	//convert the Hz values into m/z and list the signals
	for i := uint32(0); i < scan.Profile.PeakCount; i++ {
		for j := uint32(0); j < scan.Profile.Chunks[i].Nbins; j++ {
			fmt.Println(scanevent.Convert(scan.Profile.FirstValue+float64(scan.Profile.Chunks[i].Firstbin+j)*scan.Profile.Step)+float64(scan.Profile.Chunks[i].Fudge), scan.Profile.Chunks[i].Signal[j])
		}
	}
}

func PrintAllScans(filename string) {
	hdr := new(unthermo.FileHeader)
	info := new(unthermo.RawFileInfo)
	rh := new(unthermo.RunHeader)

	//save position in file after reading, we need to sequentially
	//read some things in order to get to actuall byte addresses
	pos := unthermo.ReadFile(filename, 0, 0, hdr)
	ver := hdr.Version

	pos = unthermo.ReadFile(filename, pos, ver, new(unthermo.SequencerRow))
	pos = unthermo.ReadFile(filename, pos, 0, new(unthermo.AutoSamplerInfo))
	unthermo.ReadFile(filename, pos, ver, info)

	//in info we finally have an address, let's read the MS RunHeader,
	//it contains besides general info two interesting addresses:
	//ScanindexAddr (with the scan headers) and ScantrailerAddr (which
	//includes orbitrap Hz-m/z conversion parameters and info about the scans)
	unthermo.ReadFile(filename, info.Preamble.RunHeaderAddr[0], ver, rh)

	//read all scanindexentries
	nScans := uint64(rh.SampleInfo.LastScanNumber - rh.SampleInfo.FirstScanNumber + 1)
	scanindexentries := make([]unthermo.ScanIndexEntry, nScans)
	for i := range scanindexentries {
		unthermo.ReadFile(filename, rh.ScanindexAddr+uint64(i)*scanindexentries[i].Size(ver), ver, &scanindexentries[i])
	}

	//For later conversion of frequency values to m/z, we need a ScanEvent
	//The list of them starts an uint32 later than ScantrailerAddr
	//the uint32 contains the number of ScanEvents, but we know this
	//already through SampleInfo
	pos = rh.ScantrailerAddr + 4

	//the ScanEvents are of variable size and have no pointer to
	//them, we need to read at least all the ones preceding n
	//but as on modern systems we have enough memory, we read them all
	scanevents := make([]unthermo.ScanEvent, nScans)
	for i := range scanevents {
		pos = unthermo.ReadFile(filename, pos, ver, &scanevents[i])
	}

	for s := range scanindexentries {
		//read Scan Packet for the above scan number
		scan := new(unthermo.ScanDataPacket)
		unthermo.ReadFile(filename, rh.DataAddr+scanindexentries[s].Offset, 0, scan)

		//convert the Hz values into m/z and list the signals
		for i := uint32(0); i < scan.Profile.PeakCount; i++ {
			for j := uint32(0); j < scan.Profile.Chunks[i].Nbins; j++ {
				fmt.Println(s+1, scanevents[s].Convert(scan.Profile.FirstValue+float64(scan.Profile.Chunks[i].Firstbin+j)*scan.Profile.Step)+float64(scan.Profile.Chunks[i].Fudge), scan.Profile.Chunks[i].Signal[j])
			}
		}
	}

}

func PrintOther(filename string, instrument int) {

	hdr := new(unthermo.FileHeader)
	info := new(unthermo.RawFileInfo)
	rh := new(unthermo.RunHeader)

	//save position in file after reading, we need to sequentially
	//read some things in order to get to actuall byte addresses
	pos := unthermo.ReadFile(filename, 0, 0, hdr)
	ver := hdr.Version

	pos = unthermo.ReadFile(filename, pos, ver, new(unthermo.SequencerRow))
	pos = unthermo.ReadFile(filename, pos, 0, new(unthermo.AutoSamplerInfo))
	unthermo.ReadFile(filename, pos, ver, info)

	//in info we finally have an address, let's read the RunHeader,
	//it contains an interesting address: ScanIndexAddr
	//There is another address DataAddr, which points to the data alone,
	//but the same information is contained in the CIndexEntry containers
	//at ScanIndexAddr
	unthermo.ReadFile(filename, info.Preamble.RunHeaderAddr[instrument], ver, rh)

	nScan := uint64(rh.SampleInfo.LastScanNumber - rh.SampleInfo.FirstScanNumber + 1)
	cindexentries := make([]unthermo.CIndexEntry, nScan)
	for i := range cindexentries {
		unthermo.ReadFile(filename, rh.ScanindexAddr+uint64(i)*cindexentries[i].Size(ver), ver, &cindexentries[i])
	}
	fmt.Println(cindexentries[:10])
}

func Filter(filename string) {

	hdr := new(unthermo.FileHeader)
	info := new(unthermo.RawFileInfo)
	rh := new(unthermo.RunHeader)

	//save position in file after reading, we need to sequentially
	//read some things in order to get to actuall byte addresses
	pos := unthermo.ReadFile(filename, 0, 0, hdr)
	ver := hdr.Version

	pos = unthermo.ReadFile(filename, pos, ver, new(unthermo.SequencerRow))
	pos = unthermo.ReadFile(filename, pos, 0, new(unthermo.AutoSamplerInfo))
	unthermo.ReadFile(filename, pos, ver, info)

	//in info we finally have an address, let's read the MS RunHeader,
	//it contains besides general info two interesting addresses:
	//ScanindexAddr (with the scan headers) and ScantrailerAddr (which
	//includes orbitrap Hz-m/z conversion parameters and info about the scans)
	unthermo.ReadFile(filename, info.Preamble.RunHeaderAddr[0], ver, rh)

	//read all Scan Index Entries
	nScans := uint64(rh.SampleInfo.LastScanNumber - rh.SampleInfo.FirstScanNumber + 1)
	scanindexentries := make([]unthermo.ScanIndexEntry, nScans)
	for i := range scanindexentries {
		unthermo.ReadFile(filename, rh.ScanindexAddr+uint64(i)*scanindexentries[i].Size(ver), ver, &scanindexentries[i])
	}

	//For later conversion of frequency values to m/z, we need a ScanEvent
	//The list of them starts an uint32 later than ScantrailerAddr
	//the uint32 contains the number of ScanEvents, but we know this
	//already through SampleInfo
	pos = rh.ScantrailerAddr + 4

	//the ScanEvents are of variable size and have no pointer to
	//them, we need to read at least all the ones preceding n
	//but as on modern systems we have enough memory, we read them all
	scanevents := make([]unthermo.ScanEvent, nScans)
	for i := range scanevents {
		pos = unthermo.ReadFile(filename, pos, ver, &scanevents[i])
	}

	m := make(map[float64]float32)
	for s := range scanindexentries {
		//read Scan Packet for the above scan number
		scan := new(unthermo.ScanDataPacket)
		unthermo.ReadFile(filename, rh.DataAddr+scanindexentries[s].Offset, 0, scan)

		//convert the Hz values into m/z and list the signals
		for i := uint32(0); i < scan.Profile.PeakCount; i++ {
			for j := uint32(0); j < scan.Profile.Chunks[i].Nbins; j++ {
				mz := scanevents[s].Convert(scan.Profile.FirstValue+float64(scan.Profile.Chunks[i].Firstbin+j)*scan.Profile.Step) + float64(scan.Profile.Chunks[i].Fudge)
				if mz > 720 && mz < 723 {
					m[mz] += scan.Profile.Chunks[i].Signal[j]
					//fmt.Println(s, scanevents[s].Convert(scan.Profile.FirstValue+float64(scan.Profile.Chunks[i].Firstbin+j)*scan.Profile.Step)+float64(scan.Profile.Chunks[i].Fudge), scan.Profile.Chunks[i].Signal[j])
				}
			}
		}
	}
	fmt.Println(len(m))
	var keys []float64
	for k := range m {
		keys = append(keys, k)
	}
	sort.Float64s(keys)
	fmt.Println(keys[0], keys[len(keys)-1])
}
